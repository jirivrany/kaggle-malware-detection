# coding: utf-8
import gc
import pickle
import numpy as np
import pandas as pd
from itertools import combinations
from tqdm import tqdm

import utils
import conversions


train = pd.read_pickle('../input/train.pkl')
print("TRAIN LOADED")
test = pd.read_pickle('../input/test.pkl')
print("TEST LOADED")

# merge both datasets

target = train['HasDetections']
del train['HasDetections']

target.to_pickle('../input/target.pkl')
print("Target saved")
del(target)

train_rows = train.shape[0]

df_full = pd.concat([train, test])

print("MERGED") 
del(train)
del(test)
gc.collect()

# prepare the features
true_numerical_columns = [
    'Census_ProcessorCoreCount',
    'Census_PrimaryDiskTotalCapacity',
    'Census_SystemVolumeTotalCapacity',
    'Census_TotalPhysicalRAM',
    'Census_InternalPrimaryDiagonalDisplaySizeInInches',
    'fe_avsig_gamer_freq',
    'fe_cpucores_region_freq', 
    'fe_cpucores_oemname_freq',
    'fe_geoname_oemname_freq', 
    'fe_non_primary_drive_MB',
    'fe_screen_area'

    #'Census_InternalPrimaryDisplayResolutionHorizontal',
    #'Census_InternalPrimaryDisplayResolutionVertical',
#    'Census_InternalBatteryNumberOfCharges'
]

new_numerical_columns = [
    'non_primary_drive_MB',
    'aspect_ratio',
    'Screen_Area'
]

def display_features(df):
    # https://www.kaggle.com/adityaecdrid/simple-feature-engineering-xd
    df['fe_non_primary_drive_MB'] = df['Census_PrimaryDiskTotalCapacity'] - df['Census_SystemVolumeTotalCapacity']

    df['aspect_ratio'] = df['Census_InternalPrimaryDisplayResolutionHorizontal']/ df['Census_InternalPrimaryDisplayResolutionVertical']

    df['fe_monitor_dims'] = df['Census_InternalPrimaryDisplayResolutionHorizontal'].astype(str) + '*' + df['Census_InternalPrimaryDisplayResolutionVertical'].astype('str')
    
  
    df['fe_screen_area'] = (df['aspect_ratio'] * (df['Census_InternalPrimaryDiagonalDisplaySizeInInches']**2))/(df['aspect_ratio']**2 + 1)
    
    df.drop('aspect_ratio', axis=1, inplace=True)

    return df
    
def fill_nan(df):

    df['Census_ThresholdOptIn'] = df['Census_ThresholdOptIn'].fillna(1)
    df['Census_IsWIMBootEnabled'] = df['Census_IsWIMBootEnabled'].fillna(1)
    df['Wdft_IsGamer'] = df['Wdft_IsGamer'].fillna(0)
    
    return df


true_numerical_columns = true_numerical_columns + new_numerical_columns
num_datatypes = ['int8', 'int16', 'int32', 'float16', 'float32']
true_numerical_columns  = [c for c, v in utils.DTYPES.items() if v in num_datatypes]


df_full = display_features(df_full)


print("categorical features prepared")

binary_variables = [c for c in df_full.columns if df_full[c].nunique() == 2]

categorical_columns = [c for c in df_full.columns
                       if (c not in true_numerical_columns) & (c not in binary_variables)]



#one more test with SmartScreen 


df_full['SmartScreen']=df_full['SmartScreen'].astype(str)
df_full['SmartScreen']=df_full['SmartScreen'].str.lower()
df_full['SmartScreen'].replace({"promt":"prompt",
                        "promprt":"prompt",
                        "00000000":"0",
                        "enabled":"on",
                        "of":"off" ,
                        "deny":"0" , # just one
                        "requiredadmin":"requireadmin"
                       },inplace=True)
df_full['SmartScreen'] = df_full['SmartScreen'].astype("category")
print("SmartScreen ready")

# compute some ratios
print("Preparing ratios")
nrows = df_full.shape[0]
df_full['fe_avsig_gamer_freq'] = df_full.groupby(['AvSigVersion','Wdft_IsGamer'])['OsBuild'].transform('count') / nrows
df_full['fe_cpucores_region_freq'] = df_full.groupby(['Census_ProcessorCoreCount','Wdft_RegionIdentifier'])['OsBuild'].transform('count') / nrows
df_full['fe_cpucores_oemname_freq'] = df_full.groupby(['Census_ProcessorCoreCount','Census_OEMNameIdentifier'])['OsBuild'].transform('count') / nrows
df_full['fe_geoname_oemname_freq'] = df_full.groupby(['GeoNameIdentifier','Census_OEMNameIdentifier'])['OsBuild'].transform('count') / nrows


#santiize bad value of AvSigVersion
df_full['AvSigVersion'] = df_full['AvSigVersion'].astype(str)
df_full.at[5244810, 'AvSigVersion'] = '1.273.1444.0'
df_full['AvSigVersion'] = df_full['AvSigVersion'].astype('category')

#encode the versions
versions = ['EngineVersion', 'AppVersion', 'AvSigVersion']
for version in tqdm(versions):
    colname = version + '_factor'
    df_full[colname] = utils.add_factor_sort(df_full, version)
    

print("Frequency variables")
to_freq_encode = []
for col in categorical_columns:
    if df_full[col].nunique() > 1000:
        print(col, df_full[col].nunique())
        to_freq_encode.append(col)

for variable in tqdm(to_freq_encode):
    freq_enc_dict = utils.frequency_encoding_single(df_full, variable)
    df_full[variable] = df_full[variable].map(lambda x: freq_enc_dict.get(x, np.nan))
    categorical_columns.remove(variable)


print("Categorical encoding")
for col in tqdm(categorical_columns):
    if col == 'MachineIdentifier':
        continue
    #senti = df_full[col].nunique() + 1    
    df_full[col] = pd.factorize(df_full[col])[0]
    df_full[col] = df_full[col].astype('int32')
    df_full[col] = df_full[col] + abs(df_full[col].min()) + 1


print("Correlation features")

corr_df = pd.read_csv('../EDA/corr_features_filtered.csv')


for idx, com in tqdm(corr_df.iterrows()):
    new_name = "fe_{}_{}_{:4f}".format(com['colA'], com['colB'], com['corr_score'])
    pokus = df_full.groupby([com['colA'], com['colB']])['OsBuild'].transform('count') / df_full.shape[0]
    df_full[new_name] = pokus


print("3 cols correlation features")

corr_df = pd.read_csv('../EDA/3cols_corr_165.csv')


for idx, com in tqdm(corr_df.iterrows()):
    new_name = "fe_{}_{}_{}_{:4f}".format(com['colA'], com['colB'], com['colC'], com['corr_score'])
    pokus = df_full.groupby([com['colA'], com['colB'], com['colC']])['OsBuild'].transform('count') / df_full.shape[0]
    df_full[new_name] = pokus


print("ratio correlation features")

corr_df = pd.read_csv('../EDA/features_ratios.csv')

for i, com in enumerate(corr_df.iterrows()):
    try:
        pokus =  df_full[com[1]] / df_full[com[0]]
    except TypeError:
        print("nelze delit {}".format(com))
    else:        
        new_name = "fe_{}_{}_ratio_{:4f}".format(com['colA'], com['colB'], com['corr_score'])
        df_full[new_name] = pokus    

# remove bad cols

bad_cols = [
 'IsBeta',
 'OsVer',
 'AutoSampleOptIn',
 'Census_DeviceFamily',
 'Census_IsPortableOperatingSystem',
 'Census_IsFlightingInternal',
 'PuaMode',
 'HasTpm',
 'Census_IsFlightsDisabled',
 'ProductName',
 'Platform',
 'OsPlatformSubRelease',
 'Census_IsVirtualDevice',
 'UacLuaenable',
 'Census_InternalPrimaryDisplayResolutionHorizontal',
 'Census_InternalPrimaryDisplayResolutionVertical',
 'Census_IsAlwaysOnAlwaysConnectedCapable',
 'Census_ProcessorManufacturerIdentifier',
 'Census_ChassisTypeName',
 'Census_InternalBatteryNumberOfCharges',
 'Census_InternalBatteryType',
 'fe_AVProductStatesIdentifier_Census_DeviceFamily_0.154504',
 'fe_AVProductStatesIdentifier_AVProductsInstalled_0.154501',
 'fe_AVProductStatesIdentifier_IsProtected_0.154501',
 'fe_AVProductsInstalled_AutoSampleOptIn_0.150419',
 'fe_IsBeta_AVProductsInstalled_0.150438',
 'fe_AVProductsInstalled_Census_DeviceFamily_0.150447',
 'fe_SmartScreen_Census_DeviceFamily_0.184216',
 'fe_IsBeta_AVProductStatesIdentifier_0.154501',
 'fe_ProductName_AVProductStatesIdentifier_0.154501',
 'fe_AVProductStatesIdentifier_PuaMode_0.166995'
 ]

df_full.drop(bad_cols, axis=1, inplace=True)



# split back and save
train = df_full[:train_rows]
test = df_full[train_rows:]

del df_full
gc.collect()

train = utils.reduce_mem_usage(train)
test = utils.reduce_mem_usage(test)

train.to_pickle('../input/train-encoded-full-corr-v3.pkl')
test.to_pickle('../input/test-encoded-full-corr-v3.pkl')


# save final categorical_columnscategorical_columns
with open('../input/categoricals.pkl', 'wb') as pickle_file:
    pickle.dump(categorical_columns, pickle_file)
print("retained categorical columns", categorical_columns)
