# coding: utf-8

import numpy as np
import pandas as pd
from tqdm import tqdm

from utils import frequency_encoding
import conversions

train = pd.read_pickle('../input/train.pkl')
print("TRAIN LOADED")
test = pd.read_pickle('../input/test.pkl')
print("TEST LOADED")


true_numerical_columns = [
    'Census_ProcessorCoreCount',
    'Census_PrimaryDiskTotalCapacity',
    'Census_SystemVolumeTotalCapacity',
    'Census_TotalPhysicalRAM',
    'Census_InternalPrimaryDiagonalDisplaySizeInInches',
    #'Census_InternalPrimaryDisplayResolutionHorizontal',
    #'Census_InternalPrimaryDisplayResolutionVertical',
    'Census_InternalBatteryNumberOfCharges'
]

new_numerical_columns = [
    'non_primary_drive_MB',
    'aspect_ratio',
    'Screen_Area'
]

def display_features(df):
    # https://www.kaggle.com/adityaecdrid/simple-feature-engineering-xd
    df['M_non_primary_drive_MB'] = df['Census_PrimaryDiskTotalCapacity'] - df['Census_SystemVolumeTotalCapacity']

    df['aspect_ratio'] = df['Census_InternalPrimaryDisplayResolutionHorizontal']/ df['Census_InternalPrimaryDisplayResolutionVertical']

    df['monitor_dims'] = df['Census_InternalPrimaryDisplayResolutionHorizontal'].astype(str) + '*' + df['Census_InternalPrimaryDisplayResolutionVertical'].astype('str')
    
  
    df['Screen_Area'] = (df['aspect_ratio'] * (df['Census_InternalPrimaryDiagonalDisplaySizeInInches']**2))/(df['aspect_ratio']**2 + 1)
    
    df.drop('aspect_ratio', axis=1, inplace=True)

    return df
    
def fill_nan(df):

    df['Census_ThresholdOptIn'] = df['Census_ThresholdOptIn'].fillna(1)
    df['Census_IsWIMBootEnabled'] = df['Census_IsWIMBootEnabled'].fillna(1)
    df['Wdft_IsGamer'] = df['Wdft_IsGamer'].fillna(0)
    
    return df

def battery_charges(df):
    mx = df['Census_InternalBatteryNumberOfCharges'].max()
    df['Census_InternalBatteryNumberOfCharges'] = df['Census_InternalBatteryNumberOfCharges'].replace(mx, 0)
    df['Census_InternalBatteryNumberOfCharges'] = df['Census_InternalBatteryNumberOfCharges'].fillna(0)
    df['Census_InternalBatteryNumberOfCharges'] = df['Census_InternalBatteryNumberOfCharges'].astype('int')

    return df


def has_battery(df):
    df['FE_HasBatery'] = np.where(df['Census_InternalBatteryType'].isna(), 0, 1)
    return df

train['Census_ChassisTypeName'] = train['Census_ChassisTypeName'].fillna('unknown')
test['Census_ChassisTypeName'] = test['Census_ChassisTypeName'].fillna('unknown')
train['Census_ChassisTypeName'] = train['Census_ChassisTypeName'].map(conversions.CHASIS_MAP)
test['Census_ChassisTypeName'] = test['Census_ChassisTypeName'].map(conversions.CHASIS_MAP)

true_numerical_columns = true_numerical_columns + new_numerical_columns

train = display_features(train)
test = display_features(test)

train = has_battery(train)
test = has_battery(test)

bad_cols = [
 'IsBeta',
 'OsVer',
 'AutoSampleOptIn',
 'Census_DeviceFamily',
 'Census_IsPortableOperatingSystem',
 'Census_IsFlightingInternal',
 'PuaMode',
 'HasTpm',
 'Census_IsFlightsDisabled',
 'ProductName',
 'Platform',
 'OsPlatformSubRelease',
 'Census_IsVirtualDevice',
 'UacLuaenable',
 'Census_InternalPrimaryDisplayResolutionHorizontal',
 'Census_InternalPrimaryDisplayResolutionVertical',
 'Census_IsAlwaysOnAlwaysConnectedCapable',
 'Census_ProcessorManufacturerIdentifier'
 ]

train.drop(bad_cols, axis=1, inplace=True)
test.drop(bad_cols, axis=1, inplace=True)

binary_variables = [c for c in train.columns if train[c].nunique() == 2]

categorical_columns = [c for c in train.columns
                       if (c not in true_numerical_columns) & (c not in binary_variables)]



frequency_encoded_variables = [
    'Census_OEMModelIdentifier',
    'CityIdentifier',
    'Census_FirmwareVersionIdentifier',
    'AvSigVersion',
    'Census_ProcessorModelIdentifier',
    'Census_OEMNameIdentifier',
    'DefaultBrowsersIdentifier'
]

print("Frequency variables")
for variable in tqdm(frequency_encoded_variables):
    freq_enc_dict = frequency_encoding(train, test, variable)
    train[variable] = train[variable].map(
        lambda x: freq_enc_dict.get(x, np.nan))
    test[variable] = test[variable].map(lambda x: freq_enc_dict.get(x, np.nan))
    categorical_columns.remove(variable)


print("Categorical encoding")
indexer = {}
for col in tqdm(categorical_columns):
    if col == 'MachineIdentifier':
        continue
    _, indexer[col] = pd.factorize(train[col])

for col in tqdm(categorical_columns):
    if col == 'MachineIdentifier':
        continue
    train[col] = indexer[col].get_indexer(train[col])
    test[col] = indexer[col].get_indexer(test[col])

train.to_pickle('../input/train-encoded.pkl')
test.to_pickle('../input/test-encoded.pkl')